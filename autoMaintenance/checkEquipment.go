package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

)

type alias struct {
	ID                string `json:"equipment_id"`
	EquipmentLocation string `json:"equipment_location"`
	EquipmentName     string `json:"equipment_name"`
	EquipmentStatus   string `json:"equipment_status"`
	LastMaintained    string `json:"last_maintained"`
}

func (e *Eqp1) Convert() alias {
	var a alias = alias(*e)
	return a
}

func contains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func getJson(url string, target interface{}) error {
	r, err := http.Get(url)
	if err != nil {
		return err
	}
	defer r.Body.Close()

	return json.NewDecoder(r.Body).Decode(target)
}

func getMaintenancesForEqp(eqpID string) []Maintenance {
	url := "http://host.docker.internal:5000/maintenance/equipment/" + eqpID
	var resp AutoGenerated
	err := getJson(url, &resp)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(len(resp.Data))
	return resp.Data
}

func getEqp(eqpID string) (Eqp1, error) {
	url := "http://host.docker.internal:4999/equipment/" + eqpID
	var resp eqpResp
	err := getJson(url, &resp)
	if err != nil {
		log.Println(err)
		log.Println("ERROR")
		return resp.Eqp1, err
	}
	return resp.Eqp1, err
}

func getBusyTechs(dateStr string) []string {
	url := "http://host.docker.internal:5000/maintenance/busy_technicians/" + dateStr
	var resp BusyTechsResp
	err := getJson(url, &resp)
	if err != nil {
		fmt.Println(err)
	}
	return resp.Data
}

func getTechnicians() []User {
	technicians := []User{}
	url := "http://host.docker.internal:3001/all"
	var resp UserResp
	err := getJson(url, &resp)
	if err != nil {
		fmt.Println(err)
	}
	// for each technician, get name and append to slice
	for _, u := range resp.Users {
		if u.Role == "TECHNICIAN" {
			technicians = append(technicians, u)
		}
	}
	return technicians
}

func testFunc(rw http.ResponseWriter, req *http.Request) {
	if req.Method != "POST" {
		rw.WriteHeader(405)
		rw.Write([]byte("Only POST Method Allowed"))
	}

	decoder := json.NewDecoder(req.Body)
	var data PostReqData
	err := decoder.Decode(&data)
	if err != nil {
		log.Panicln(err)
	}
	eqpID := data.EquipmentID
	// update equipment status
	// make post request
	e, err := getEqp(eqpID)
	if err != nil {
		rw.Header().Set("Content-Type", "application/json")
		rw.WriteHeader(404)
		resp := []byte(`{"msg": "Error getting entry, please check that equipment_id is valid"}`)
		rw.Write(resp)
		return
	}
	e.EquipmentStatus = "Down"
	jsonData, err := json.Marshal(e)
	if err != nil {
		log.Fatal(err)
	}
	resp, err := http.Post("http://host.docker.internal:4999/equipment/"+eqpID,
		"application/json",
		bytes.NewBuffer(jsonData))
	if err != nil {
		log.Fatal(err)
		rw.Header().Set("Content-Type", "application/json")
		rw.WriteHeader(500)
		resp := []byte(`{"msg": "Error updating equipment status"}`)
		rw.Write(resp)
		return
	}
	var res map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&res)
	fmt.Println(res["json"])

	maintenances := getMaintenancesForEqp(eqpID)
	fmt.Println("===============")
	fmt.Println(maintenances)
	fmt.Println("===============")
	status := false
	date := time.Now().AddDate(0, 0, 1)
	// while status is false, for current date, check if any maintenance date is same
	for !status {
		dateStr := date.Format("2006-01-02")
		for _, m := range maintenances {
			if m.ScheduleDate == dateStr {
				fmt.Println("=== DATE MATCH ===")
				status = true
				break
			}
		}
		if status {
			fmt.Println("Abort Scheduling due to earlier date existing")
			rw.Header().Set("Content-Type", "application/json")
			rw.WriteHeader(403)
			resp := []byte(`{"msg": "Equipment has a scheduled Maintenanace which is earlier than the next available auto-scheduled date."}`)
			rw.Write(resp)
			break
		}
		// invoke api to check , if code = 404

		availList := getTechnicians()
		busyTechs := getBusyTechs(dateStr)
		// remove technician from available list
		for i := range availList {
			if contains(busyTechs, availList[i].ID) {
				availList = append(availList[:i], availList[i+1:]...)
			}
		}

		if len(availList) > 0 {
			// invoke maintenance controller to schedule maintenance
			testarr := []string{}
			e := e.Convert()
			var st SubmitTechnician
			st.ID, st.Name, st.Phone = availList[0].ID, availList[0].Name, availList[0].Phone
			details := map[string]interface{}{"equipment": e, "schedule_date": dateStr, "partlist": testarr, "technician": st}
			jsonData, err := json.Marshal(details)
			fmt.Println(details)
			if err != nil {
				fmt.Println(err)
			}
			resp, err := http.Post("http://host.docker.internal:8080/schedule_maintenance",
				"application/json",
				bytes.NewBuffer(jsonData))
			if err != nil {
				log.Fatal(err)
			}

			rw.Header().Set("Content-Type", "application/json")
			rw.WriteHeader(403)
			jsonResp := []byte(`{"msg": "Successfully scheduled a Maintenance for Equipment."}`)
			rw.Write(jsonResp)

			var res map[string]interface{}
			json.NewDecoder(resp.Body).Decode(&res)
			fmt.Println(res["json"])

			status = true
		} else {
			date = date.AddDate(0, 0, 1)
		}

	}

}
